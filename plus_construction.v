Require Import HoTT.
Require Import UnivalenceAxiom.


(* Fixpoint iterated_prod (A : Type) (m : nat) : Type := *)
(*   match m with *)
(*     | O => Unit (* A^0 := 1 *) *)
(*     | m.+1 => (iterated_prod A m) * A (* A^m+1 := A^m * A *) *)
(*   end. *)

(* Fixpoint iterated_concat {A : Type} {a0 : A} {m : nat} : iterated_prod (a0 = a0) m -> a0 = a0 := *)
(*   match m with *)
(*     | O => const idpath       (*  *) *)
(*     | m.+1 => fun p => match p with *)
(*                          (prod, p) => iterated_concat prod @ p *)
(*                        end *)
(*   end. *)

(* Fixpoint iterated_concat {A : Type} {a0 : A} (l : list (a0 = a0)) : (a0 = a0) := *)
(*   match l with *)
(*   | nil => idpath *)
(*   | cons p l => p @ iterated_concat l *)
(*   end. *)

Fixpoint functor_list {A B : Type} (f : A -> B) (l : list A) : list B :=
  match l with
    | nil => nil
    | cons a l => cons (f a) (functor_list f l)
  end.

Fixpoint iterated_eComp {A : Type} (l : list (A <~> A)) : A <~> A :=
  match l with
    | nil => equiv_idmap
    | cons e l => e oE iterated_eComp l
  end.
  
               
Section Plus_Construction.
  (* Assume that Aut E is normally generated by a single element alpha, and that alpha is inside a perfect subgroup *)
  Context {E : hSet}.
  Context (alpha : E <~> E).
  (* Perfect implies that there are elements s,t such that alpha = s@t@s^@t^ *)
  Variables s t : E <~> E.
  Context (perfect : alpha = s oE t oE s^-1 oE t^-1).
  (* Aut E is normally generated by alpha, so s and t are products of conjugates of alpha *)
  Variables s_list t_list : list (E <~> E).
  Context (normally_generated_s : s = iterated_eComp (functor_list (fun e : E <~> E => e^-1 oE alpha oE e^-1) s_list)).
  Context (normally_generated_t : t = iterated_eComp (functor_list (fun e : E <~> E => e^-1 oE alpha oE e^-1) t_list)).

  (* Now we should be able to define the plus construction in two steps. *)
  (* 1: Kill alpha in BAut E *)
  (* 2: Find the correct 2-sphere in this type, and kill it *)

  (* The map E <~> E -> loops (BAut E) *)
  Definition loops_baut : E <~> E -> loops (Build_pType (BAut E) _).
  Proof.
    intro e. apply path_baut. exact e.
  Defined.  

  (* Another notation for pointed maps *)
  Notation "A ->* B" := (pMap (Build_pType A _) (Build_pType B _)).
  Definition pconst (A B : pType) : pMap A B :=
    Build_pMap A B (const (point B)) idpath.
    
  Global Instance ispointed_S1 : IsPointed S1 := base.
  (* First the map S1 -> BAut E corresponding to alpha *)
  Definition alpha_map : S1 ->* (BAut E).
  Proof.
    srapply @Build_pMap.
    - srapply @S1_rec.
      (* Basepoint goes to basepoint *)
      + exact (point (BAut E)).
      + exact (loops_baut alpha).
    - reflexivity.
  Defined.

  (* X1 is the BAut E where we kill this map *)
  Definition X1 := pushout alpha_map (const tt).
  Instance ispointed_X1 : IsPointed X1 := pushl base.
  Definition baut_to_X1 : (BAut E) ->* X1.
    srapply @Build_pMap.
    - intro e. apply push. exact (inl e).
    - reflexivity. (* exact (pp base). *)
  Defined.


  (* Now we show that the path coming from alpha is killed in X1 *)
  Definition kill_alpha : ap (baut_to_X1) (loops_baut alpha) = idpath.
  Proof.
    transitivity (pmap_compose (loops_functor baut_to_X1) (loops_functor alpha_map) loop).
    { apply inverse. simpl.
      refine (concat_1p _ @ _). refine (concat_p1 _ @ _).
      apply (ap (ap (fun e : BAut E => push (inl e)))).
      refine (concat_1p _ @ concat_p1 _ @ _).
      apply S1_rec_beta_loop. }
    apply inverse.
    refine (_ @ pointed_htpy (loops_functor_compose baut_to_X1 alpha_map) loop).
    apply inverse.
    transitivity (loops_functor (Build_pMap (Build_pType S1 _) (Build_pType X1 _) (const (point X1)) idpath) loop).
    apply (ap (fun f : S1 ->* X1 => loops_functor f loop)).
    { apply path_pmap.
      srapply @Build_pHomotopy.
      - intro x. unfold const. simpl. unfold point. unfold ispointed_X1.
        refine (_ @ (pp base)^).
        exact (pp x).
      - simpl. refine (concat_p1 _ @ _). apply concat_pV. }
    simpl. refine (concat_1p _ @ concat_p1 _ @ _).
    apply ap_const.
  Defined.

  (* Now we show that s and t are killed in X1 *)
  Definition kill_s : ap (baut_to_X1) (loops_baut s) = idpath.

  
     

        